/* eslint-disable import/prefer-default-export,prefer-destructuring */
import fs from 'fs';

import * as file from './../utils/files/file';
import { getActiveLogger } from '../utils/log/winston';
import * as projectConfigurationService from './project-configuration-service';
const log = getActiveLogger();

/**
 * Generates the basic folder structure for the project
 * @param projectName the project name, which will be the top most project generated
 * @returns {Promise<void>}
 */
async function generateProjectFolders(projectName) {
  log.verbose('Project File Service - generateProjectFolders()');

  if (!fs.existsSync(projectName)) {
    fs.mkdirSync(projectName);
    fs.mkdirSync(`${projectName}/src`);
    log.info('Successfully created project folder structure');
  } else {
    throw new Error('Project already exists!');
  }
}

/**
 * Generates the basic index.js file.
 * @param projectName the project's name
 * @returns {Promise<void>}
 */
async function generateIndexFile(projectName) {
  log.verbose('Project File Service - generateIndexFile()');

  const path = `${projectName}/src/index.js`;
  const contents = file.loadTemplate('./../../../templates/js/index.js');
  file.writeFile(path, contents);
  log.info(`Successfully generated file: ${path}`);
}

/**
 * Genrerates the basic project's package json. The output of this file will be used later if
 * other tools need to be in the package json.
 * @param configs the project configuration's object
 * @returns {Promise<void>}
 */
async function generatePackageJson(configs) {
  log.verbose('Project File Service - generatePackageJson()');

  const projectConfigs = configs.projectConfigurations;
  const path = `${projectConfigs.projectName}/package.json`;

  // load the contents from the template file
  let contents = file.loadTemplate('./../../../templates/js/package.json');

  // turn the template contents into json
  contents = JSON.parse(contents);
  contents.name = projectConfigs.projectName;
  contents.description = projectConfigs.description;
  contents.version = projectConfigs.version;
  contents.authors = projectConfigs.author.split(',');

  // turn the contents back to JSOn
  contents = JSON.stringify(contents, null, ' ');
  file.writeFile(path, contents);
  log.info(`Successfully generated file: ${path}`);
}

/**
 * Generates the project README
 * @returns {Promise<void>}
 */
async function generateReadMe(configs) {
  log.verbose('Project Files Service - generateReadMe()');
  const projectName = configs.projectConfigurations.projectName;
  const description = configs.projectConfigurations.description;
  const path = `${projectName}/README.md`;
  const contents = `# ${projectName}\n`
    + `${description}\n\n`
    + '## Installation'
    + '\n'
    + '`npm install`'
    + '\n\n'
    + '## Usage'
    + '\n'
    + '`npm start`'
    + '\n\n'
    + 'Generated by [@hammer-io](https://github.com/hammer-io/tyr)';

  file.writeFile(path, contents);
  log.info(`Successfully generated file: ${path}`);
}

/**
 * Generates a tyr file
 * @param configs the configurations object
 * @returns {Promise<void>}
 */
export async function generateTyrfile(configs) {
  await projectConfigurationService.writeToConfigFile(configs);
}

/**
 * Genereates the basic file structure and files needed for a node project
 * @param configs the configurations object
 * @returns {Promise<void>}
 */
export async function generateBasicNodeFiles(configs) {
  log.verbose('Project File Service - generateBasicNodeFiles()');
  const projectName = configs.projectConfigurations.projectName;
  await generateProjectFolders(projectName);
  await generateIndexFile(projectName);
  await generatePackageJson(configs);
  await generateReadMe(configs);
}

